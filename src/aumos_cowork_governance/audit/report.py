"""Compliance report generator.

Produces Markdown or HTML compliance summary reports from audit data.
Reports group events by type, highlight policy violations, and summarise
cost and PII detection statistics.

Example
-------
>>> from pathlib import Path
>>> from aumos_cowork_governance.audit.logger import AuditLogger
>>> from aumos_cowork_governance.audit.report import ComplianceReportGenerator
>>> audit = AuditLogger(Path("/tmp/audit.jsonl"))
>>> gen = ComplianceReportGenerator(audit)
>>> md = gen.generate_markdown()
>>> Path("/tmp/report.md").write_text(md)
"""
from __future__ import annotations

import json
from collections import Counter
from datetime import datetime, timezone
from pathlib import Path

from aumos_cowork_governance.audit.logger import AuditLogger


class ComplianceReportGenerator:
    """Generates compliance reports from audit log data.

    Parameters
    ----------
    logger:
        The :class:`AuditLogger` instance to read from.
    """

    def __init__(self, logger: AuditLogger) -> None:
        self._logger = logger

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def generate_markdown(
        self,
        title: str = "Governance Compliance Report",
        records: list[dict[str, object]] | None = None,
    ) -> str:
        """Generate a Markdown compliance report.

        Parameters
        ----------
        title:
            Report title (default: ``"Governance Compliance Report"``).
        records:
            Optional pre-filtered record list.

        Returns
        -------
        str
            Complete Markdown document.
        """
        data = records if records is not None else self._logger.read_all()
        stats = self._compute_stats(data)
        now = datetime.now(tz=timezone.utc).isoformat()

        lines: list[str] = [
            f"# {title}",
            "",
            f"**Generated:** {now}",
            f"**Total events:** {stats['total']}",
            "",
            "---",
            "",
            "## Event Summary",
            "",
            "| Event Type | Count |",
            "| --- | --- |",
        ]
        for event, count in sorted(stats["by_event"].items(), key=lambda x: -x[1]):
            lines.append(f"| `{event}` | {count} |")

        lines += [
            "",
            "## Policy Violations",
            "",
        ]
        blocks = stats["blocks"]
        if blocks:
            lines += [
                "| Timestamp | Policy | Message |",
                "| --- | --- | --- |",
            ]
            for block in blocks:
                ts = block.get("timestamp", "")
                policy = block.get("policy", "")
                message = str(block.get("message", "")).replace("|", "\\|")
                lines.append(f"| {ts} | `{policy}` | {message} |")
        else:
            lines.append("_No policy blocks recorded in this period._")

        lines += [
            "",
            "## Cost Summary",
            "",
            f"- API calls logged: **{stats['api_calls']}**",
            f"- Estimated total cost: **${stats['total_cost_usd']:.4f} USD**",
            "",
            "## PII Events",
            "",
            f"- PII warnings: **{stats['pii_warns']}**",
            f"- PII blocks: **{stats['pii_blocks']}**",
            "",
            "## Approval Requests",
            "",
            f"- Total queued: **{stats['approvals_queued']}**",
            "",
            "---",
            "",
            "_Report generated by aumos-cowork-governance._",
        ]
        return "\n".join(lines)

    def generate_html(
        self,
        title: str = "Governance Compliance Report",
        records: list[dict[str, object]] | None = None,
    ) -> str:
        """Generate an HTML compliance report.

        Parameters
        ----------
        title:
            Report title.
        records:
            Optional pre-filtered record list.

        Returns
        -------
        str
            Complete HTML document with inline styles.
        """
        data = records if records is not None else self._logger.read_all()
        stats = self._compute_stats(data)
        now = datetime.now(tz=timezone.utc).isoformat()

        event_rows = "".join(
            f"<tr><td><code>{event}</code></td><td>{count}</td></tr>"
            for event, count in sorted(stats["by_event"].items(), key=lambda x: -x[1])
        )

        if stats["blocks"]:
            block_rows = "".join(
                "<tr><td>{ts}</td><td><code>{policy}</code></td><td>{msg}</td></tr>".format(
                    ts=b.get("timestamp", ""),
                    policy=b.get("policy", ""),
                    msg=str(b.get("message", "")),
                )
                for b in stats["blocks"]
            )
            block_table = f"""
            <table>
              <tr><th>Timestamp</th><th>Policy</th><th>Message</th></tr>
              {block_rows}
            </table>"""
        else:
            block_table = "<p><em>No policy blocks recorded in this period.</em></p>"

        return f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{title}</title>
  <style>
    body {{ font-family: sans-serif; max-width: 900px; margin: 40px auto; color: #222; }}
    h1 {{ border-bottom: 2px solid #333; }}
    h2 {{ margin-top: 2em; }}
    table {{ border-collapse: collapse; width: 100%; }}
    th, td {{ border: 1px solid #ccc; padding: 8px 12px; text-align: left; }}
    th {{ background: #f0f0f0; }}
    code {{ background: #f5f5f5; padding: 2px 4px; border-radius: 3px; }}
    .stat {{ font-weight: bold; }}
    footer {{ margin-top: 3em; font-size: 0.85em; color: #888; }}
  </style>
</head>
<body>
  <h1>{title}</h1>
  <p><strong>Generated:</strong> {now}</p>
  <p><strong>Total events:</strong> <span class="stat">{stats['total']}</span></p>
  <hr>

  <h2>Event Summary</h2>
  <table>
    <tr><th>Event Type</th><th>Count</th></tr>
    {event_rows}
  </table>

  <h2>Policy Violations</h2>
  {block_table}

  <h2>Cost Summary</h2>
  <ul>
    <li>API calls logged: <span class="stat">{stats['api_calls']}</span></li>
    <li>Estimated total cost: <span class="stat">${stats['total_cost_usd']:.4f} USD</span></li>
  </ul>

  <h2>PII Events</h2>
  <ul>
    <li>PII warnings: <span class="stat">{stats['pii_warns']}</span></li>
    <li>PII blocks: <span class="stat">{stats['pii_blocks']}</span></li>
  </ul>

  <h2>Approval Requests</h2>
  <ul>
    <li>Total queued: <span class="stat">{stats['approvals_queued']}</span></li>
  </ul>

  <footer>Report generated by aumos-cowork-governance.</footer>
</body>
</html>
"""

    def save_markdown(
        self,
        output_path: Path,
        title: str = "Governance Compliance Report",
        records: list[dict[str, object]] | None = None,
    ) -> None:
        """Write a Markdown report to disk.

        Parameters
        ----------
        output_path:
            Destination file path.
        title:
            Report title.
        records:
            Optional pre-filtered record list.
        """
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(
            self.generate_markdown(title=title, records=records), encoding="utf-8"
        )

    def save_html(
        self,
        output_path: Path,
        title: str = "Governance Compliance Report",
        records: list[dict[str, object]] | None = None,
    ) -> None:
        """Write an HTML report to disk.

        Parameters
        ----------
        output_path:
            Destination file path.
        title:
            Report title.
        records:
            Optional pre-filtered record list.
        """
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(
            self.generate_html(title=title, records=records), encoding="utf-8"
        )

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _compute_stats(self, data: list[dict[str, object]]) -> dict[str, object]:
        """Compute aggregate statistics from a list of audit records."""
        event_counter: Counter[str] = Counter()
        blocks: list[dict[str, object]] = []
        api_calls: int = 0
        total_cost: float = 0.0
        pii_warns: int = 0
        pii_blocks: int = 0
        approvals_queued: int = 0

        for record in data:
            event = str(record.get("event", "unknown"))
            event_counter[event] += 1

            if event == "policy_block":
                blocks.append(record)
                policy_name = str(record.get("policy", ""))
                if "pii" in policy_name.lower():
                    pii_blocks += 1

            elif event == "policy_warn":
                policy_name = str(record.get("policy", ""))
                if "pii" in policy_name.lower():
                    pii_warns += 1

            elif event in {"api_call", "api_cost"}:
                api_calls += 1
                cost_raw = record.get("cost_usd") or record.get("estimated_cost_usd")
                if cost_raw is not None:
                    try:
                        total_cost += float(cost_raw)  # type: ignore[arg-type]
                    except (TypeError, ValueError):
                        pass

            elif event == "policy_approve_queued":
                approvals_queued += 1

        return {
            "total": len(data),
            "by_event": dict(event_counter),
            "blocks": blocks,
            "api_calls": api_calls,
            "total_cost_usd": total_cost,
            "pii_warns": pii_warns,
            "pii_blocks": pii_blocks,
            "approvals_queued": approvals_queued,
        }
